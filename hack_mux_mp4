#!/usr/bin/env perl
use warnings;
use strict;
#
# Read h264 stream and embed it in a mp4 container
#

# FIXME - calculate these values from the h264 stream
my $m_size_bytes = 37525873;
my $m_fps = 30; # This probably needs to be on the cmdline - TODO ?!?
                # (it looks like the packet_27 SPS generated by the rpi
                # doesnt have any timing_info_present, so we cannot get that
                # from the incoming stream :-(

# - each entry is the offset in the mdat to the next 'sample'
# - it looks like samples are - for all intents - 'frames'
my @stsz_offsets;

# Some static values for this encoder
my $mdhd_timescale = 1000000;   # set in mvhd & mdhd, used in tkhd & stts
my $stts_sample_delta = $mdhd_timescale/$m_fps;  # set in stts
                                # used in stts, stsc, stsz

my $packet_header_size = 8;     # 32bit length, 32bit tag

use File::Spec;

# allow the libs to be in the bin dir
use FindBin;
use lib File::Spec->catdir($FindBin::RealBin,"lib");
use lib File::Spec->catdir($ENV{HOME},"s/bin/lib");

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

use MPEG::NAL;



sub packet_generic {
    my $type = shift;
    my @contents = @_;

    my $length;
    for my $fragment (@contents) {
        $length += length($fragment);
    }

    # add in size and type header
    $length += 4 + 4;

    my $length_buf = pack('N',$length);

    die("bad type len") if (length($type) != 4);

    return ($length_buf,$type,@contents);
}

sub packet_ftyp {
    my $buf = pack('a4N(a4)2',
        'isom', # major_brand
        0,      # minor_version
        'mp41', 'avc1'
    );

    return packet_generic('ftyp',$buf);
}

sub packet_padding {
    my $size = shift;
    my $buf = "\000"x$size;
    return packet_generic('____',$buf);
}

sub packet_mvhd {
    my $buf = pack('NNNNNNnnN2N9N6N',
        0,      # version
        0,      # ctime
        0,      # mtime
        $mdhd_timescale, # timescale (played with this set to 1)
        scalar(@stsz_offsets)*$stts_sample_delta, # duration (plays when set to 0)
        0x10000, # rate
        0x100,  # volume
        0,0,0,  # reserved
        0x10000,0,0,0,0x10000,0,0,0,0x40000000, # matrix
        0,0,0,0,0,0,    # pre_defined ??
        2,      # next_track_ID
    );
    return packet_generic('mvhd',$buf);
}

sub packet_mdhd {
    my $buf = pack('NNNNNnn',
        0,      # version
        0,      # ctime
        0,      # mtime
        $mdhd_timescale, # timescale
        scalar(@stsz_offsets)*$stts_sample_delta, # duration (plays when set to 0)
        0,      # lang (actually 1bit pad, 3* 5bit char)
        0,      # pre_defined
    );
    return packet_generic('mdhd',$buf);
}

sub packet_tkhd {
    my $buf = pack('CC3NNNNNN2nnnnN9NN',
        0,      # version
        0,0,1,  # flags 0x1==track_enabled
        0,      # ctime
        0,      # mtime
        1,      # track_ID
        0,      # reserved
        scalar(@stsz_offsets)*$stts_sample_delta, # duration
        0,0,    # reserved
        0,      # layer
        0,      # alternate_group
        0,      # volume
        0,      # reserved
        0x10000,0,0,0,0x10000,0,0,0,0x40000000, # matrix
        0x5000000, # width - TODO calculate these two
        0x2d00000, # height (both abstract units, used for aspect ratio)
    );
    return packet_generic('tkhd',$buf);
}

sub packet_avcC {
    my $unk = pack('C*',
        # all unknown
        1,0x4d,0x40,0x1e,0xff,0xe0,0
    );
    return packet_generic('avcC',$unk);
}

sub packet_stts {
    my $buf = pack('NNNN',
        0,      # version
        1,      # entry_count
        scalar(@stsz_offsets), # sample_count[0]
        $stts_sample_delta, # sample_delta0 (interval between samples)
    );
    return packet_generic('stts',$buf);
}

sub packet_stsc {
    # Sample to chunk list
    my $buf = pack('NNNNN',
        0,      # version
        1,      # entry_count
        1,      # first_chunk[0]
        scalar(@stsz_offsets), # samples_per_chunk[0]
        1,      # sample_description_index[0]
    );
    return packet_generic('stsc',$buf);
}

sub packet_stsz {
    my $buf = pack('NNNN*',
        0,      # version
        0,      # sample_size
        scalar(@stsz_offsets), # sample_count
        @stsz_offsets,
    );
    return packet_generic('stsz',$buf);
}

sub packet_stco {
    my $offset = shift;
    my $buf = pack('NNN',
        0,      # version
        1,      # entry_count
        $offset, # chunk_offset[0]
    );
    return packet_generic('stco',$buf);
}

sub print_packet_mdat {
    my $length = $m_size_bytes; # size of my sample stream
    my $head = pack('Na4',
        $length +4 +4,
        'mdat'
    );
    print($head);

    my $stream = MPEG::NAL->new();
    $stream->open($ARGV[0]);

    # remove the hardcoded list and prepare for using our calculated list
    @stsz_offsets = ();

    # TODO:
    # each sample in stsz is the length of a group of packet_27,28,25
    # or a packet_21.
    # the sample pointer points at the inserted packet_27, the packet_25 is
    # still present in the stream, but no sample points at it.
    my $packet_27;
    my $packet_28;

    my $got_length=0;
    while(1) {
        # skip the header
        $stream->read_bytes(4);

        my $buf = $stream->resync();
        last if (!defined($buf));

        my $packet_len = length($buf);
        last if ($packet_len == 0);

        my $type = unpack('C',$buf);

        my $packet_len_enc = pack('N',$packet_len);
        $buf = $packet_len_enc.$buf;

        # FIXME - types are only part of this field
        if ($type == 0x27) {
            $packet_27 = $buf;
            next;
        }
        if ($type == 0x28) {
            $packet_28 = $buf;
            next;
        }

        # TODO
        # - could avoid this dance if the raspivid command is always using "-ih"
        if ($type == 0x25) {
            if ($packet_28) {
                $buf = $packet_28 . $buf;
            }
            if ($packet_27) {
                $buf = $packet_27 . $buf;
            }
        }

        push @stsz_offsets, length($buf);
        $got_length += length($buf);
        print($buf);

        # if we have exactly how much we are hardcoded to expect, stop
        if ($got_length == $length) {
            last;
        }
    }

    die("length got $got_length want $length") if ($length != $got_length);
    return;
}

sub container_avc1 {
    my $buf = pack('CCCCCCn',
        0,0,0,0,0,0,    # reserved
        1,      # data_reference_index
    );
    my $unk = pack('C*',
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        5,0,2,0xd0,0,0x48,0,0,0,0x48,0,0,0,0,0,0,
        0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0x18,0xff,0xff,
    );
    return packet_generic('avc1',$buf,$unk,@_);
}

sub container_stsd {
    my $buf = pack('NN',
        0,      # version
        1,      # entry_count - TODO, this should be calculated from contents
    );
    return packet_generic('stsd',$buf,@_);
}

# Containers with no special variables
sub container_mdia { return packet_generic('mdia',@_); }
sub container_minf { return packet_generic('minf',@_); }
sub container_moov { return packet_generic('moov',@_); }
sub container_stbl { return packet_generic('stbl',@_); }
sub container_trak { return packet_generic('trak',@_); }

# Generate an output file in quickstart order
# TODO
# - needs a two pass reader to read the input stream in pass1 and  collect
#   the data needed for the stts stsc stsz and stco packets
sub main_quickstart() {
    print(packet_ftyp());
    print(container_moov(
        packet_mvhd(),
        container_trak(
            packet_tkhd(),
            packet_padding(0x1c), # in place of edts
            container_mdia(
                packet_mdhd(),
                packet_padding(0x25), # in place of hdlr
                container_minf(
                    packet_padding(0x0c), # in place of vmhd
                    packet_padding(0x1c), # in place of dinf
                    container_stbl(
                        container_stsd(
                            container_avc1(
                                packet_avcC(),
                            ),
                        ),
                        packet_stts(),
                        packet_padding(0x44), # in place of stss
                        packet_stsc(),
                        packet_stsz(),
                        packet_stco(0x1f05+8), # FIXME - needs to be calculated
                    ),
                ),
            ),
        ),
        packet_padding(0x23), # in place of udta
    ));
    print(packet_padding(0)); # in place of wide
    print_packet_mdat();
}

# Generate an output in the order that requires no seeking
sub main() {
    my @pre_mdat = packet_ftyp();
    #push @pre_mdat, packet_padding(0); # in place of wide

    my $mdat_offset;
    for my $buf (@pre_mdat) {
        $mdat_offset += length($buf);
    }

    print(@pre_mdat);
    print_packet_mdat();
    print(container_moov(
        packet_mvhd(),
        container_trak(
            packet_tkhd(),
            #packet_padding(0x1c), # in place of edts
            container_mdia(
                packet_mdhd(),
                #packet_padding(0x25), # in place of hdlr
                container_minf(
                    #packet_padding(0x0c), # in place of vmhd
                    #packet_padding(0x1c), # in place of dinf
                    container_stbl(
                        container_stsd(
                            container_avc1(
                                packet_avcC(),
                            ),
                        ),
                        packet_stts(),
                        #packet_padding(0x44), # in place of stss
                        packet_stsc(),
                        packet_stsz(),
                        packet_stco($mdat_offset+$packet_header_size),
                    ),
                ),
            ),
        ),
        #packet_padding(0x23), # in place of udta
    ));
}
unless (caller) {
    main();
}


