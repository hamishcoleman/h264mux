#!/usr/bin/env perl
use warnings;
use strict;
#
# Quick and dirty TS dumper
#

use IO::File;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

# Is this pid formatted as a PSI?
my $pid_ispsi = {
    0 => 1,
};

sub handle_pat {
    my $db = shift;
    my $buf = shift;

    while( length($buf) >7 ) {
        my ($program_number, $pid, $rest) = unpack('nna*', $buf);
        $buf = $rest;
        $pid = $pid & 0x1fff;
        printf("PAT: program_number=0x%04x, PID=0x%04x\n",
            $program_number,
            $pid,
        );
        $pid_ispsi->{$pid} = 1;
    }
    if (length($buf) != 4) {
        die("Length leaves no room for CRC");
    }
}

sub handle_pmt {
    my $db = shift;
    my $buf = shift;

    my ($PCR_PID, $program_info_length, $rest) = unpack('nna*', $buf);
    $buf = $rest;

    $db->{PCR_PID} = $PCR_PID & 0x1fff;
    $program_info_length= $program_info_length & 0xfff;

    # TODO: decode program_info descriptors
    $buf = substr($buf, $program_info_length);

    while( length($buf) >4 ) {
        my ($stream_type, $pid, $es_info_len, $rest) = unpack('Cnna*', $buf);
        $buf = $rest;

        $pid = $pid & 0x1fff;

        $es_info_len = $es_info_len & 0xfff;

        # TODO: decode es info descriptors
        $buf = substr($buf, $es_info_len);

        printf("PMT stream_type=0x%02x, elementry_PID=0x%04x\n",
            $stream_type,
            $pid,
        );
    }

    if (length($buf) != 4) {
        print("\n");
        die("Remainder length for CRC is not 4");
    }

}

sub handle_section {
    my $buf = shift;
    my $db = {};

    my $length;
    my $rest;
    ($db->{table_id}, $length, $rest) = unpack('Cna*', $buf);
    $buf = $rest;

    # $db->{section_syntax_indicator} = ($length & 0x8000) > 0;
    # '0' = $length & 0x4000
    # reserved = $length & 0x3000
    $length = $length & 0xfff;
    if ($length > length($buf)) {
        die("section length too long");
    }
    $buf = substr($buf,0,$length);

    my $ver;
    ($db->{stream_id}, $ver, $db->{section_number}, $db->{last_section_number}, $rest) = unpack('nCCCa*', $buf);
    $db->{version_number} = ($ver >> 1) & 0x1f;
    $db->{current_next_indicator} = $ver & 1;
    $buf = $rest;

    printf("Section: TID=0x%02x, SID=0x%s, VER=0x%x(%s), nr=%i/%i\n",
        $db->{table_id},
        $db->{stream_id},
        $db->{version_number}, $db->{current_next_indicator} ? "cur":"next",
        $db->{section_number}, $db->{last_section_number},
    );

    if ($db->{table_id} == 0) {
        handle_pat($db, $buf);
    } elsif ($db->{table_id} == 0x2) {
        handle_pmt($db, $buf);
    } else {
        print("                                    ");
        my @bytes = unpack('C59', $buf);
        for my $i (@bytes) {
            printf("%02x",$i);
        }
        print("\n");
    }
}

sub handle_payload {
    my $pid = shift;
    my $buf = shift;

    if ($pid_ispsi->{$pid}) {
        my ($offset, $rest) = unpack('Ca*', $buf);
        $buf = $rest;

        if ($offset != 0) {
            die("Unhandled PSI offset byte");
        }

        handle_section($buf);
        return;
    }

    # not PSI, just dump it..
    print("\n");
    print("                                    ");
    my @bytes = unpack('C59', $buf);
    for my $i (@bytes) {
        printf("%02x",$i);
    }
    print("\n");
}

sub handle_packet {
    my $buf = shift;
    my $db = {};

    my ($sync, $pid_hi, $pid_lo, $cc, $rest) = unpack("C4a*",$buf);
    $buf = $rest;

    if ($sync != 0x47) {
        die("sync error");
    }

    $db->{TEI} = ($pid_hi & 0x80) ? "T":" ";
    $db->{PUSI} = ($pid_hi & 0x40) ? "P":" ";
    $db->{pri} = ($pid_hi & 0x20) ? "U":" ";
    $db->{pid} = (($pid_hi & 0x1f) <<8) | $pid_lo;
    #$db->{TSC} = ($cc & 0xc0) >> 6;
    $db->{adaptation} = ($cc & 0x30) >> 4;
    $db->{counter} = ($cc & 0xf);

    my $flags_pkt = $db->{TEI}.$db->{PUSI}.$db->{pri};
    printf("PKT:%s:%04x:%x ", $flags_pkt, $db->{pid}, $db->{counter});

    if ($db->{adaptation} >1) {
        my ($len, $flags, $rest) = unpack("CCa*", $buf);
        $buf = $rest;

        printf("A%02x ",$len);

        if ($len < 1) {
            die("unexpected adaptation length");
        }

        if ($flags != 0 && $flags != 0x10 && $flags != 0x50) {
            die("unexpected adaptation flags $flags");
        }

        if ($flags & 0x10) {
            # Random access 0x40 bit set
            # PCF flag 0x10 set
            $db->{PCR} = unpack("a6", $buf);
        }

        $buf = substr($buf,$len-1);
    } else {
        printf("    ");
    }

    if (defined($db->{PCR})) {
        my $pcr;
        for my $ch (split(//,$db->{PCR})) {
            $pcr .= sprintf("%02x", ord($ch));
        }
        printf("PCR=%s ", $pcr);
    } else {
        print("                 ");
    }

    # TODO: if adaptation_flag says there is a payload
    handle_payload($db->{pid},$buf);
}

sub main {
    my $filename = $ARGV[0];
    my $fh = IO::File->new($filename, "r");
    if (!defined($fh)) {
        die("open error");
    }

    # TODO: resync
    # for now, just assume we are in sync

    while (!$fh->eof()) {
        my $buf;
        $fh->read($buf, 188);
        handle_packet($buf);
    }

}
unless (caller) {
    main();
}
