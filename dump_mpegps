#!/usr/bin/env perl
use warnings;
use strict;
#
# Given an MPEG2 Program Stream, dump its content structure
#

package MPEG::PS::header_base;
use warnings;
use strict;

sub new {
    my $class = shift;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub offset {
    my $self = shift;
    my $val = shift;
    if (defined($val)) {
        if (defined($self->{offset})) {
            die("can only set offset once");
        }
        $self->{offset} = $val;
    }
    return $self->{offset};
}

1;

package MPEG::PS::header_01ba;
# a Program Stream pack header
use warnings;
use strict;

our @ISA = qw(MPEG::PS::header_base);

sub sync_value { 0x1ba; }

sub read {
    my $self = shift;
    my $fh = shift;

    my $size = 14;
    my $sync_hex = sprintf("0x%08x",$self->sync_value());

    $self->offset($fh->tell());

    my $buf;
    my $count = $fh->read($buf,$size);
    if ($count != $size) {
        die("read size mismatch");
    }

    my @val = unpack('NC*',$buf);

    # MPEG1 has different marker here - and different header structure
    die("bad magic") if ($val[0] != $self->sync_value());

    # check all the magic values at once
    die("bad marker") if ((($val[1] >>6) & 0x3) != 1);
    die("bad marker") if ((($val[1] >>2) & 0x1) != 1);
    die("bad marker") if ((($val[3] >>2) & 0x1) != 1);
    die("bad marker") if ((($val[5] >>2) & 0x1) != 1);
    die("bad marker") if (($val[6] & 0x1) != 1);
    die("bad marker") if (($val[9] & 0x3) != 3);

    my $h= {};
    $h->{scr} =
        (($val[1] >>3) & 0x7) << 30 |
        (($val[1] ) & 0x3) << 28 |
        (($val[2] )) << 20 |
        (($val[3] >>3) & 0x1f) << 15 |
        (($val[3] ) & 0x3) << 13 |
        (($val[4] )) << 5 |
        (($val[5] >>3) & 0x1f);
    $h->{scr_ext} =
        (($val[5] ) & 0x3) << 7 |
        (($val[6] >>1));
    $h->{bitrate} =
        (($val[7] )) <<15 |
        (($val[8] )) <<6 |
        (($val[9] >>2));
    # TODO - check the reserved bytes?
    $h->{stuff_len} =
        (($val[10]) & 0x7);

    $count = $fh->read($buf,$h->{stuff_len});
    if ($count != $h->{stuff_len}) {
        die("read size mismatch");
    }
    $h->{stuff_bytes} = $buf;

    $self->{val} = $h;

    return $self;
}

1;

package MPEG::PS::header_01bb;
# a system header
use warnings;
use strict;

our @ISA = qw(MPEG::PS::header_base);

sub sync_value { 0x1bb; }

sub read {
    my $self = shift;
    my $fh = shift;

    my $size = 6;
    my $sync_hex = sprintf("0x%08x",$self->sync_value());

    $self->offset($fh->tell());

    my $buf;
    my $count = $fh->read($buf,$size);
    if ($count != $size) {
        die("read size mismatch");
    }

    my @val = unpack('Nn',$buf);

    die("bad magic") if ($val[0] != $self->sync_value());

    my $h= {};
    $h->{length} = $val[1];

    $count = $fh->read($buf,$h->{length});
    if ($count != $h->{length}) {
        die("read size mismatch");
    }

    @val = unpack('C*',$buf);

    # TODO - decode this header?
    @{$h->{_data}} = @val;

    $self->{val} = $h;

    return $self;
}

1;

package MPEG::PS;
use warnings;
use strict;

use IO::File;

sub new {
    my $class = shift;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub open {
    my $self = shift;
    my $filename = shift;
    my $fh = IO::File->new($filename,"r");
    if (!defined($fh)) {
        die("Could not open $filename: $!");
    }
    $self->{_fh} = $fh;
    return $self;
}

# peek at the next dword, which might be a valid sync header
sub peek_sync {
    my $self = shift;
    my $sync_size = 4;

    my $buf;
    my $count = $self->{_fh}->read($buf,$sync_size);
    if ($count != $sync_size) {
        die("read size mismatch");
    }

    # rewind back over the sync byte
    $self->{_fh}->seek(-$sync_size,1);
    return unpack("N",$buf);
}

# a very simple sync byte search
sub resync {
    my $self = shift;
    my $sync_value = 0x1ba;

    while(!$self->{_fh}->eof()) {
        my $dword = $self->peek_sync();
        if ($dword == $sync_value) {
            return $self;
        }

        # skip to the next possible position
        $self->{_fh}->seek(1,1);
    }
}

sub read_header {
    my $self = shift;

    my $headers = {
        0x1ba => 'MPEG::PS::header_01ba',
        0x1bb => 'MPEG::PS::header_01bb',
    };

    my $dword = $self->peek_sync();

    if (defined($headers->{$dword})) {
        my $header = $headers->{$dword}->new();
        $self->{headers}{$dword} = $header->read($self->{_fh});
        return $self->{headers}{$dword};
    }
    return undef;
}


1;

package main;
use warnings;
use strict;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

sub main {
    my $ps = MPEG::PS->new();
    $ps->open($ARGV[0]);

    $ps->resync();

    while (my $header = $ps->read_header()) {
        printf("0x%08x: %s\n",$header->offset(),ref($header));
    }

    print Dumper($ps);
}
unless (caller) {
    main();
}
