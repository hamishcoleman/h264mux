#!/usr/bin/env perl
use warnings;
use strict;
#
# Given an MPEG2 Program Stream, dump its content structure
#

package MPEG::PES::packet_base;
use warnings;
use strict;

sub new {
    my $class = shift;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub offset {
    my $self = shift;
    my $val = shift;
    if (defined($val)) {
        if (defined($self->{offset})) {
            die("can only set offset once");
        }
        $self->{offset} = $val;
    }
    return $self->{offset};
}

sub length_variable {
    my $self = shift;
    my $val = shift;
    if (defined($val)) {
        $self->{length_variable} = $val;
    }
    return $self->{length_variable};
}

sub indent {
    my $self = shift;
    my $val = shift;
    if (defined($val) && $val>0) {
        $self->{indent} = $val;
    }
    return $self->{indent};
}

sub length {
    my $self = shift;
    my $length_fixed = $self->length_fixed();
    my $length_variable = $self->length_variable() || 0;
    return $length_fixed + $length_variable;
}

sub read {
    my $self = shift;
    my $stream = shift;

    $self->offset($stream->current_offset());

    my $buf = $stream->read_bytes($self->length_fixed());

    $self->{val} = $buf;
    return $self;
}

sub to_string {
    my $self = shift;

    my $s = '';

    my $offset = $self->offset();
    if (defined($offset)) {
        $s .= sprintf("0x%08x",$offset);
    }

    $s .= sprintf("(0x%08x)",$self->length());
    $s .= " " x ($self->indent() || 1);
    $s .= ref($self);

    return $s;
}

# return the spaces to indent a new line for additional data
sub _extra_indent {
    my $self = shift;

    my $s;
    if (defined($self->offset())) {
        $s .= " "x10; # skip the offset field
    }
    $s .= " "x12; # skip the length field
    $s .= " " x $self->indent(); # indent as needed
    $s .= "|- "; # clearly mark the extra data
    return $s;
}

1;

package MPEG::PES::packet_unknown;
# class to hold unknown packets
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_base);

sub length_fixed { 0; }

1;

package MPEG::PES::packet_generic;
# a packet with a 16bit length field
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_base);

sub length_fixed { 6; }

sub read {
    my $self = shift;
    my $stream = shift;

    $self->SUPER::read($stream);

    my @val = unpack('Nn',$self->{val});

    die("bad magic") if ($val[0] != $self->sync_value());

    my $h= {};
    $self->length_variable($val[1]);

    my $buf = $stream->read_bytes($self->length_variable());

    @val = unpack('C*',$buf);

    # TODO - where to decode this header?
    @{$h->{_data}} = @val;

    $self->{val} = $h;

    return $self;
}

1;

package MPEG::PES::packet_generic_large;
# A large sized packet, so dont store all of the data (or dump it)
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_generic);

sub read {
    my $self = shift;
    my $stream = shift;

    $self->SUPER::read($stream);

    # TODO - apply a size threshold to deleting?
    delete $self->{val}{_data};

    return $self;
}

1;

package MPEG::PES::packet_generic_peshead;
# A packet, that might contain the optional PES Header
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_generic);

sub read {
    my $self = shift;
    my $stream = shift;

    $self->SUPER::read($stream);

    my @val = $self->{val}{_data};

    my $h = {};
    $h->{PES_Header} = (($val[0] & 0xc0) == 0x80);

    if ($h->{PES_Header}) {
        $h->{PES_scrambling_control}   = (($val[0] & 0x30) >>4);
        $h->{PES_priority}             = (($val[0] & 0x08) >>3);
        $h->{data_alignment_indicator} = (($val[0] & 0x04) >>2);
        $h->{copyright}                = (($val[0] & 0x02) >>1);
        $h->{original_or_copy}         = (($val[0] & 0x01));
    }

    $self->{val} = $h;

    return $self;
}

sub to_string {
    my $self = shift;

    my $s = $self->SUPER::to_string();
    if ($self->{val}{PES_Header}) {
        for my $key (sort(keys(%{$self->{val}}))) {
            my $val = $self->{val}{$key};
            $s .= "\n" . $self->_extra_indent();
            $s .= sprintf("%s = %s", $key, $val);
        }
    }
    return $s;
}

1;

package MPEG::PES::packet_01b9;
# program end code
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_base);

sub sync_value { 0x1b9; }
sub length_fixed { 4; }

sub read {
    my $self = shift;
    my $stream = shift;

    $self->SUPER::read($stream);

    my @val = unpack('N',$self->{val});
    die("bad magic") if ($val[0] != $self->sync_value());

    delete $self->{val};

    # this pack packet ends the whole stream, so gets unindented
    $self->indent($self->indent()-1);

    return $self;
}

1;

package MPEG::PES::packet_01ba;
# a Program Stream pack packet
# FIXME - this packet (optionally) contains the system_header (0x1bb)
# and is not followed by it, as coded here
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_base);

sub sync_value { 0x1ba; }
sub length_fixed { 14; }

sub read {
    my $self = shift;
    my $stream = shift;

    $self->SUPER::read($stream);

    my @val = unpack('NC*',$self->{val});

    # MPEG1 has different marker here - and different header structure
    die("bad magic") if ($val[0] != $self->sync_value());

    # check all the magic values at once
    die("bad marker") if ((($val[1] >>6) & 0x3) != 1);
    die("bad marker") if ((($val[1] >>2) & 0x1) != 1);
    die("bad marker") if ((($val[3] >>2) & 0x1) != 1);
    die("bad marker") if ((($val[5] >>2) & 0x1) != 1);
    die("bad marker") if (($val[6] & 0x1) != 1);
    die("bad marker") if (($val[9] & 0x3) != 3);

    my $h= {};
    $h->{scr} =
        (($val[1] >>3) & 0x7) << 30 |
        (($val[1] ) & 0x3) << 28 |
        (($val[2] )) << 20 |
        (($val[3] >>3) & 0x1f) << 15 |
        (($val[3] ) & 0x3) << 13 |
        (($val[4] )) << 5 |
        (($val[5] >>3) & 0x1f);
    $h->{scr_ext} =
        (($val[5] ) & 0x3) << 7 |
        (($val[6] >>1));
    $h->{bitrate} =
        (($val[7] )) <<15 |
        (($val[8] )) <<6 |
        (($val[9] >>2));
    # TODO - check the reserved bytes?
    $self->length_variable((($val[10]) & 0x7));

    my $buf = $stream->read_bytes($self->length_variable());
    $h->{stuff_bytes} = $buf;

    $self->{val} = $h;

    # this pack packet starts a new group, so is unindented
    $self->indent($self->indent()-1);
    # this packet has children, so they get indented
    $stream->current_indent($self->indent()+1);

    return $self;
}

sub to_string {
    my $self = shift;

    my $s = $self->SUPER::to_string();
    $s .= sprintf(" scr=%i", $self->{val}{scr});
    return $s;
}

1;

package MPEG::PES::packet_01bb;
# a system header
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_generic);
sub sync_value { 0x1bb; }

# TODO - decode contents:
# marker_bits x3
# rate_bound
# audio_bound
# fixed_flag
# CSPS_flag
# system_audio_lock_flag
# system_video_lock_flag
# video_bound
# packet_rate_restriction_flag
# reserved
# while bit7==1
#       stream_id
#       optional
#              stream_id_extension
#       P-STD_buffer_bound_scale
#       P-STD_buffer_size_bound

1;

package MPEG::PES::packet_01bc;
# Program Stream Map
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_generic);
sub sync_value { 0x1bc; }

# TODO - decode contents:
# current_next_indicator
# single_extension_stream_flag
# reserved
# program_stream_map_version
# reserved
# marker_bit
# program_stream_info_length
#       n * descriptor()
# elementary_stream_map_length
#       n * :
#               stream_type
#               elementary_stream_id
#               elementary_stream_info_length
#                       n * descriptor()
# CRC_32

1;

package MPEG::PES::packet_01bd;
# private_stream_1
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_generic_large);
sub sync_value { 0x1bd; }

# TODO: work out what the contents are
1;

package MPEG::PES::packet_01be;
# padding stream
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_generic_large);
sub sync_value { 0x1be; }

# No contents
1;

package MPEG::PES::packet_01c0;
# video stream number 0
# TODO - make this a generic audio stream thing
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_generic_peshead);
sub sync_value { 0x1c0; }

1;

package MPEG::PES::packet_01e0;
# video stream number 0
# TODO - make this a generic video stream thing
use warnings;
use strict;

our @ISA = qw(MPEG::PES::packet_generic_peshead);
sub sync_value { 0x1e0; }

1;

package MPEG::PES;
use warnings;
use strict;

use IO::File;

sub new {
    my $class = shift;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub open {
    my $self = shift;
    my $filename = shift;
    my $fh = IO::File->new($filename,"r");
    if (!defined($fh)) {
        die("Could not open $filename: $!");
    }
    $self->{_fh} = $fh;
    return $self;
}

sub current_offset {
    my $self = shift;
    return $self->{_fh}->tell();
}

sub current_indent {
    my $self = shift;
    my $val = shift;
    if (defined($val) && $val>0) {
        $self->{current_indent} = $val;
    }
    return $self->{current_indent};
}

sub read_bytes {
    my $self = shift;
    my $size = shift;
    die("need size") if (!defined($size));

    my $buf;
    my $count = $self->{_fh}->read($buf,$size);
    if ($count != $size) {
        die("read size mismatch");
    }
    return $buf;
}

# peek at the next dword, which might be a valid packet start code
sub peek_packet {
    my $self = shift;
    my $sync_size = 4;

    my $buf = $self->read_bytes($sync_size);

    # rewind back over the sync byte
    $self->{_fh}->seek(-$sync_size,1);
    return unpack("N",$buf);
}

# a very simple sync byte search
# TODO - this sync value is actually "0x00 0x00 0x01", with "0xba"
# as the only valid starting streamid
sub resync {
    my $self = shift;
    my $sync_value = 0x1ba;

    while(!$self->{_fh}->eof()) {
        my $dword = $self->peek_packet();
        if ($dword == $sync_value) {
            return $self;
        }

        # skip to the next possible position
        $self->{_fh}->seek(1,1);
    }
}

sub read_packet {
    my $self = shift;

    return undef if $self->{_fh}->eof();

    my $packets = {
        0x1b9 => 'MPEG::PES::packet_01b9',
        0x1ba => 'MPEG::PES::packet_01ba',
        0x1bb => 'MPEG::PES::packet_01bb',
        0x1bc => 'MPEG::PES::packet_01bc',
        0x1bd => 'MPEG::PES::packet_01bd',
        0x1be => 'MPEG::PES::packet_01be',
        0x1c0 => 'MPEG::PES::packet_01c0',
        0x1e0 => 'MPEG::PES::packet_01e0',
    };

    my $dword = $self->peek_packet();

    my $class = $packets->{$dword};
    my $packet;
    if (defined($class)) {
        $packet = $class->new();
    } else {
        $packet = MPEG::PES::packet_unknown->new();
    }

    $packet->indent($self->current_indent());
    $self->{packets}{$dword} = $packet;
    $packet->read($self);

    if (!defined($class)) {
        printf("%s Unknown packet 0x%08x\n", $packet->to_string(), $dword);
        return undef;
    }

    return $packet;
}

1;

package main;
use warnings;
use strict;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

sub main {
    my $ps = MPEG::PES->new();
    $ps->current_indent(1);
    $ps->open($ARGV[0]);

    $ps->resync();

    while (my $packet = $ps->read_packet()) {
        printf("%s\n",$packet->to_string());
    }

    print Dumper($ps);
}
unless (caller) {
    main();
}
